from flask import (
    Flask, render_template, request, redirect,
    url_for, flash, session, send_from_directory
)
from flask_pymongo import PyMongo
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
from dotenv import load_dotenv

import os
import json
import random
import numpy as np
import smtplib

from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta, timezone

# ==================== ML IMPORTS ====================
from tensorflow.keras.models import load_model
from tensorflow.keras.utils import load_img, img_to_array

# ==================== LOAD ENV ====================
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv("SECRET_KEY", "dev_secret_key")

# ==================== MONGODB ====================
app.config["MONGO_URI"] = os.getenv("MONGO_URI")
mongo = PyMongo(app)
users = mongo.db.users

# ==================== TIME ====================
def now_utc():
    return datetime.now(timezone.utc)

# ==================== UPLOAD CONFIG ====================
UPLOAD_FOLDER = "uploads"
ALLOWED_EXTENSIONS = {"jpg", "jpeg", "png"}

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS

# ==================== LOAD CLASS NAMES ====================
CLASS_NAMES = []
if os.path.exists("class_names.json"):
    with open("class_names.json", "r") as f:
        CLASS_NAMES = json.load(f)

# ==================== LOAD MODEL (ONCE) ====================
model = None
try:
    model = load_model("plant_disease_model_final.keras", compile=False)
    print("✅ ML model loaded successfully")
except Exception as e:
    print("❌ Model loading failed:", e)

def preprocess_image(img_path):
    image = load_img(img_path, target_size=(224, 224))
    image = img_to_array(image) / 255.0
    return np.expand_dims(image, axis=0)

# ==================== EMAIL (OTP) ====================
def send_otp_email(email, otp):
    msg = MIMEMultipart("alternative")
    msg["From"] = os.getenv("EMAIL_USER")
    msg["To"] = email
    msg["Subject"] = "Password Reset OTP"

    html = render_template("otp_email.html", email=email, otp=otp)
    msg.attach(MIMEText(html, "html"))

    with smtplib.SMTP("smtp.gmail.com", 587) as server:
        server.starttls()
        server.login(os.getenv("EMAIL_USER"), os.getenv("EMAIL_PASSWORD"))
        server.sendmail(msg["From"], email, msg.as_string())

# ==================== ROUTES ====================

@app.route("/")
def home():
    return redirect(url_for("login"))

# ---------- LOGIN ----------
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        email = request.form["email"]
        password = request.form["password"]

        user = users.find_one({"email": email})
        if user and check_password_hash(user["password"], password):
            session["user_id"] = str(user["_id"])
            return redirect(url_for("dashboard"))

        flash("Invalid email or password", "error")

    return render_template("login.html")

# ---------- SIGNUP ----------
@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        email = request.form["email"]

        if users.find_one({"email": email}):
            flash("Email already exists", "error")
            return redirect(url_for("signup"))

        users.insert_one({
            "email": email,
            "password": generate_password_hash(request.form["password"]),
            "created_at": now_utc()
        })

        flash("Account created successfully. Please login.", "success")
        return redirect(url_for("login"))

    return render_template("signup.html")

# ---------- FORGOT PASSWORD ----------
@app.route("/forgot_password", methods=["GET", "POST"])
def forgot_password():
    if request.method == "POST":
        email = request.form["email"]
        user = users.find_one({"email": email})

        if not user:
            flash("Email not found", "error")
            return redirect(url_for("forgot_password"))

        otp = str(random.randint(100000, 999999))

        users.update_one(
            {"email": email},
            {"$set": {
                "reset_otp": otp,
                "reset_otp_expiry": now_utc() + timedelta(minutes=10)
            }}
        )

        send_otp_email(email, otp)
        session["reset_email"] = email

        flash("OTP sent to your email", "info")
        return redirect(url_for("reset_password"))

    return render_template("forgot_password.html")

# ---------- RESET PASSWORD ----------
@app.route("/reset_password", methods=["GET", "POST"])
def reset_password():
    email = session.get("reset_email")
    if not email:
        flash("Session expired. Try again.", "error")
        return redirect(url_for("forgot_password"))

    user = users.find_one({"email": email})

    if request.method == "POST":
        otp = request.form["otp"]
        password = request.form["password"]
        confirm = request.form["confirm_password"]

        if password != confirm:
            flash("Passwords do not match", "error")
            return redirect(url_for("reset_password"))

        if otp != user.get("reset_otp"):
            flash("Invalid OTP", "error")
            return redirect(url_for("reset_password"))

        if now_utc() > user.get("reset_otp_expiry"):
            flash("OTP expired", "error")
            return redirect(url_for("forgot_password"))

        users.update_one(
            {"email": email},
            {"$set": {"password": generate_password_hash(password)},
             "$unset": {"reset_otp": "", "reset_otp_expiry": ""}}
        )

        session.pop("reset_email", None)
        flash("Password reset successfully. Please login.", "success")
        return redirect(url_for("login"))

    return render_template("reset_password.html")

# ---------- DASHBOARD ----------
@app.route("/dashboard")
def dashboard():
    if "user_id" not in session:
        return redirect(url_for("login"))
    return render_template("index.html")

# ---------- PREDICT ----------
@app.route("/predict", methods=["POST"])
def predict():
    if "user_id" not in session:
        return redirect(url_for("login"))

    if not model:
        flash("ML model not loaded", "error")
        return redirect(url_for("dashboard"))

    file = request.files.get("file")
    if not file or file.filename == "":
        flash("No image selected", "error")
        return redirect(url_for("dashboard"))

    if not allowed_file(file.filename):
        flash("Invalid file type", "error")
        return redirect(url_for("dashboard"))

    filename = secure_filename(file.filename)
    path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    file.save(path)

    img = preprocess_image(path)
    preds = model.predict(img)[0]

    idx = np.argmax(preds)
    label = CLASS_NAMES[idx] if CLASS_NAMES else "Unknown"
    confidence = round(float(preds[idx]) * 100, 2)

    return render_template(
        "result.html",
        prediction=label,
        confidence=confidence,
        image_url=url_for("uploaded_file", filename=filename)
    )

# ---------- SERVE UPLOAD ----------
@app.route("/uploads/<filename>")
def uploaded_file(filename):
    return send_from_directory(app.config["UPLOAD_FOLDER"], filename)

# ---------- LOGOUT ----------
@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("login"))

# ==================== RUN ====================
if __name__ == "__main__":
    app.run(debug=True)
